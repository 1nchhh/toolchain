; ---
; void delay(uint16_t millis)
; ---

	assume	adl=1

virtual
	ld	hl, 0
	push	hl
	call	_delay
; ^ 48 cc
end virtual

	public	_delay
_delay:
; Timing assumes fetching from RAM (4cc) and the first timer read being valid.

; Read argument.
	pop	de
	ex	(sp), hl		; hl = millis
	push	de
; ^ 48 cc
; Abort ASAP if millis == 0.
	ld	a, l
	or	a, h
	ret	z
; ^ 13 cc
; Get the start time ASAP.
	push	hl
	call	_clock			; a = 0, euhl = start
; ^ 32 cc self
; 48 + 48 + 13 + 32 + 48 + 75 = 264 cc until start time captured
	ex	(sp), hl		; hl = millis
	push	de
; Convert (approx) from millis to clock ticks.
	dec.s	hl
	inc	hl
	ld	e, a			; euhl = millis
	ld	bc, (256 * 32768 + 500) / 1000
					; aubc = round(256 * 32768 / 1e3)
	call	__lmulu			; euhl = millis *
					;            round(256 * 32768 / 1e3)
	push	de
	push	hl
	inc	sp
	pop	hl			; uhl = millis *
					;           round(256 * 32768 / 1e3) /
					;           256
					;     = ticks
	inc	sp
	inc	sp
; Calculate the end time.
	pop	de
	pop	bc			; eubc = start
	xor	a, a			; auhl = ticks
	add	hl, bc
	adc	a, e			; auhl = start + ticks
					;      = end
; Prepare.
	ld	e, a			; euhl = end
	push	hl
virtual
	cp	a, 0
load op_cp_a: byte from $$
end virtual
	db	op_cp_a
; ^ don't care cc
.check:
; Get the current time.
	push	bc
	push	de
	call	_clock			; euhl = now, cf = 0
; ^ 42 + cc(_clock) cc
; Check if the end time has been reached.
	ld	a, e			; auhl = now
	pop	de
	pop	bc			; dubc = end
; 	or	a, a
	sbc	hl, bc
	sbc	a, e			; auhl = now - end
; ^ 48 cc
; Check again if the end time has not been reached.
	jr	c, .check
; ^ 13 cc (conditional jr taken)
; 42 + 48 + 202 + 31 + 48 + 13 = 384 cc check
	ret
; ^ 16 cc

virtual
	pop	hl
; ^ 16 cc
end virtual

; 202 - 75 + 31 + 48 + 13 + 16 + 16 = 251 cc after end time captured


	extern	_clock
	extern	__lmulu
